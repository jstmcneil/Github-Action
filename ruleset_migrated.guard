#EC2-001
let aws_ec2_securitygroupingress = Resources.*[ Type == "AWS::EC2::SecurityGroupIngress" ]
rule EC2_001 when %aws_ec2_securitygroupingress !empty {
	%aws_ec2_securitygroupingress.Properties {
		CidrIp != "0.0.0.0/0" <<EC2-001: EC2 instances must not be exposed directly to open traffic (0.0.0.0/0)>>
	}
}

#EC2-008
let aws_ec2_volume = Resources.*[ Type == "AWS::EC2::Volume" ]
rule EC2_008 when %aws_ec2_volume !empty {
	%aws_ec2_volume.Properties {
		Encrypted == true <<[EC2-008] : EC2 volumes should be encrypted>>
	}
}

#LA-001
let aws_lambda_permission = Resources.*[ Type == "AWS::Lambda::Permission" ]	
rule LA_001 when %aws_lambda_permission !empty {
	%aws_lambda_permission.Properties {
		Properties.Principal not empty <<LA-001: Lambda functions must not be publicly accessible>>
	}
}

#S3-001
let aws_s3_bucket = Resources.*[ Type == "AWS::S3::Bucket" ]
rule S3_001 when %aws_s3_bucket !empty {
	%aws_s3_bucket.Properties {
		PublicAccessBlockConfiguration.BlockPublicAcls == true <<S3-001: S3 should be set to block public ACLs>>
		PublicAccessBlockConfiguration.BlockPublicPolicy == true <<S3-001: S3 should be set to block public policies>>
		PublicAccessBlockConfiguration.IgnorePublicAcls == true <<S3-001: S3 should be set to ignore public ACLs>>
		PublicAccessBlockConfiguration.RestrictPublicBuckets == true <<S3-001: S3 should be set to restrict public buckets>>
	}
}

#S3-002
#AWS::S3::Bucket BucketEncryption.ServerSideEncryptionConfiguration not empty << S3-002: S3 bucket encryption should be enabled

#S3-011
rule S3_011 when %aws_s3_bucket !empty {
	%aws_s3_bucket.Properties {
		Tags not empty <<S3-011: S3 Bucket should contain tags>>
	}
}

#EFS-002
let aws_efs_filesystem = Resources.*[ Type == "AWS::EFS::FileSystem" ]
rule EFS_002 when %aws_efs_filesystem !empty {
	%aws_efs_filesystem.Properties {
		Encrypted == true <<EFS-002: EFS file system should be encrypted>>
	}
}

#RDS-002
let aws_rds_dbinstance = Resources.*[ Type == "AWS::RDS::DBInstance" ]
rule RDS_002 when %aws_rds_dbinstance !empty {
	%aws_rds_dbinstance.Properties {
		StorageEncrypted == true <<RDS-002: Storage encryption should be enabled>>
	}
}

#RDS-004
rule RDS_004 when %aws_rds_dbinstance !empty {
	%aws_rds_dbinstance.Properties {
		PubliclyAccessible == false <<RDS-004: Databasae should not be publicly accessible>>
	}
}

#DY-001
let aws_dynamodb_table = Resources.*[ Type == "AWS::DynamoDB::Table" ]
rule DY_001 when %aws_dynamodb_table !empty {
	%aws_dynamodb_table.Properties {
		SSESpecification.SSEEnabled == true <<DY-001: DynamoDB tables should be encrypted with CMKs>>
	}
}

#RS-002
let aws_redshift_cluster = Resources.*[ Type == "AWS::Redshift::Cluster" ]
rule RS_002 when %aws_redshift_cluster !empty {
	%aws_redshift_cluster.Properties {
		Encrypted == true <<RS-002: Storage encryption should be enabled>>
	}
}

#RS-003
rule RS_003 when %aws_redshift_cluster !empty {
	%aws_redshift_cluster.Properties {
		PubliclyAccessible == false <<RS-003: Databasae should not be publicly accessible>>
	}
}

#IAM-001
let aws_iam_role = Resources.*[ Type == "AWS::IAM::Role" ]
rule IAM_001 when %aws_iam_role !empty {
	%aws_iam_role.Properties {
		AssumeRolePolicyDocument.Statement.0.Action.0 != "*" <<IAM-001: Avoid wildcard operations when specifying IAM actions>>
	}
}

#IAM-005
let aws_iam_policy = Resources.*[ Type == "AWS::IAM::Policy" ]
rule IAM_005 when %aws_iam_policy !empty {
	%aws_iam_policy.Properties {
		PolicyName != "*" <<IAM-005: IAM identities must not have inline policy attached (i.e. users, group, roles)>>
	}
}

#IAM-006
rule IAM_006 when %aws_iam_role !empty {
	%aws_iam_role.Properties {
		AssumeRolePolicyDocument.Statement.0.Action.0 != "*.NotAction" <<IAM-006: IAM policies must not allow "NotAction">>
	}
}

#FSX-001
#AWS::FSx::FileSystem IF FileSystemType == WINDOWS, KmsKeyID not empty << FSX-001: Amazon FSx file systems must be encrypted at rest

#EMR-001
let aws_emr_cluster = Resources.*[ Type == "AWS::EMR::Cluster" ]
rule EMR_001 when %aws_emr_cluster !empty {
	%aws_emr_cluster.Properties {
		SecurityConfiguration not empty <<EMR:001: All EBS Volumes used in the EMR cluster must be encrypted>>
	}
}

#GL-001
let aws_glue_securityconfiguration = Resources.*[ Type == "AWS::Glue::SecurityConfiguration" ]
rule GL_001 when %aws_glue_securityconfiguration !empty {
	%aws_glue_securityconfiguration.Properties {
		EncryptionConfiguration not empty <<GL-001: Data stored in Glue must be encrypted>>
	}
}

#KI-001
let aws_kinesis_stream = Resources.*[ Type == "AWS::Kinesis::Stream" ]
rule KI_001 when %aws_kinesis_stream !empty {
	%aws_kinesis_stream.Properties {
		StreamEncryption.EncryptionType not empty <<KI-001: Data stored in Kinesis Data Streams / Firehose must be encrypted at rest>>
	}
}

#SM-001
let aws_sagemaker_notebookinstance = Resources.*[ Type == "AWS::SageMaker::NotebookInstance" ]
rule SM_001 when %aws_sagemaker_notebookinstance !empty {
	%aws_sagemaker_notebookinstance.Properties {
		KmsKeyID not empty <<SM-001: Data stored in SageMaker must be encrypted at rest>>
	}
}

#NE-002
let aws_neptune_dbcluster = Resources.*[ Type == "AWS::Neptune::DBCluster" ]
rule NE_002 when %aws_neptune_dbcluster !empty {
	%aws_neptune_dbcluster.Properties {
		StorageEncrypted == true <<NE-002: Data stored in Neptune DB must be encrypted. Any Read Replicas must also be encrypted.>>
	}
}

#DMS-001
let aws_dms_replicationinstance = Resources.*[ Type == "AWS::DMS::ReplicationInstance" ]
rule DMS_001 when %aws_dms_replicationinstance !empty {
	%aws_dms_replicationinstance.Properties {
		KmsKeyId not empty <<DMS-001: Replication instance storage must be encrypted>>
	}
}

#DDB-001
let aws_docdb_dbcluster = Resources.*[ Type == "AWS::DocDB::DBCluster" ]
rule DDB_001 when %aws_docdb_dbcluster !empty {
	%aws_docdb_dbcluster.Properties {
		KmsKeyID not empty <<DDB-001: Data stored in Document DB must be encrypted>>
	}
}

#SNS-003
let aws_sns_topic = Resources.*[ Type == "AWS::SNS::Topic" ]
rule SNS_003 when %aws_sns_topic !empty {
	%aws_sns_topic.Properties {
		KmsMasterKeyId not empty <<SNS-003: Data stored in SNS must be encrypted with Server Side Encryption>>
	}
}

#SQS-003
let aws_sqs_queue = Resources.*[ Type == "AWS::SQS::Queue" ]
rule SQS_003 when %aws_sqs_queue !empty {
	%aws_sqs_queue.Properties {
		KmsMasterKeyId not empty <<SQS-003: Data stored in SQS must be encrypted with Server Side Encryption>>
	}
}

#MQ-001
let aws_amazonmq_broker = Resources.*[ Type == "AWS::AmazonMQ::Broker" ]
rule MQ_001 when %aws_amazonmq_broker !empty {
	%aws_amazonmq_broker.Properties {
		EncryptionOptions.UseAwsOwnedKey == "true OR false" <<MQ-001: Data stored in Amazon MQ must be encrypted at rest>>
	}
}

#IAM-004
rule IAM_004 when %aws_iam_role !empty {
	%aws_iam_role.Properties {
		AssumeRolePolicyDocument.Statement.0.Action.0 != "*.NotPrincipal" <<IAM-004: IAM Roles must not allow all principals to assume the role (e.g., Specify explicit ARN values in priciples section on what resources/accounts can assume this role>>
	}
}

#IAM-005
##TBD

#IAM-006
#TBD

#EKS-006
let aws_iam_role_resources = Resources.*[ Type == 'AWS::IAM::Role' ]
rule EKS_006 when %aws_iam_role_resources !empty {
  %aws_iam_role_resources.Properties.Policies.PolicyDocument.Statement[*].Effect == 'Deny'
  %aws_iam_role_resources.Properties.Policies.PolicyDocument.Statement[*].Condition.Bool.'aws:SecureTransport' == 'false'
  <<EKS-006: Traffic to or from EKS resources must be encrypted in transit using TLS 1.2 or above>>
}

#LA-003
let aws_serverless_function_resources = Resources.*[ Type == 'AWS::Serverless::Function' ]
rule LA_003 when %aws_serverless_function_resources !empty {
  %aws_serverless_function_resources.Properties.Policies[*].Statement[*].Action != /."*"/
  %aws_serverless_function_resources.Properties.Policies[*].Statement[*].Resources != /."*"/
  <<LA-003: Lambda functions must not be granted full administrator access execution privileges>>
}


#LA-005
let aws_lambda_function = Resources.*[ Type == "AWS::Lambda::Function" ]
rule LA_005 when %aws_lambda_function !empty {
    %aws_lambda_function.Properties.KmsKeyArn EXISTS <<LA-005: Lambda enviornment variables must be encrypted at rest>>
}


#S3-003
let aws_s3_bucketpolicy_resources = Resources.*[ Type == 'AWS::S3::BucketPolicy' ]
rule S3_003 when %aws_s3_bucketpolicy_resources !empty {
  %aws_s3_bucketpolicy_resources.Properties.PolicyDocument.Statement[*].Effect == 'Allow'
  %aws_s3_bucketpolicy_resources.Properties.PolicyDocument.Statement[*].Condition.Bool.'aws:SecureTransport' == 'true'
  << S3-003: The S3 Bucket Policy must enforce secure HTTPS connections>>
}

#S3-006
let your_bucket = Resources.*[ Type == 'AWS::S3::Bucket' ]
let your_bucket_with_logging_configuration = %your_bucket[ Properties.LoggingConfiguration EXISTS ]

#Sub-Rule 1
rule S3_006_01 when %your_bucket_with_logging_configuration !empty {
    %your_bucket.Properties.LoggingConfiguration EXISTS << S3-006: S3 Server Access Logging must be enabled on source bucket >>
}

#Sub-Rule 2
rule S3_006_02 when %your_bucket_with_logging_configuration empty {
    %your_bucket.Properties.AccessControl == 'LogDeliveryWrite' << S3-006: S3 destination bucket should have LogDeliveryWrite as the AccessControl if LoggingConfiguration isn't specified. >>
}

#S3-007
let aws_cloudtrail_trail = Resources.*[ Type == "AWS::CloudTrail::Trail" ]
rule S3_007 WHEN %aws_cloudtrail_trail NOT EMPTY {
    %aws_cloudtrail_trail {
        Properties.IsLogging == true
        Properties.S3BucketName EXISTS
        Properties.EventSelectors[*].DataResources[*].Type == "AWS::S3::Object"
        Properties.EventSelectors[*].DataResources[*].Values[*] EXISTS
        << S3-007: Object Level Logging must be enabled>>
    }
}


#RDS-003
let aws_redshift_cluster = Resources.*[ Type == "AWS::Redshift::Cluster" ]
rule RDS_003 WHEN %aws_redshift_cluster NOT EMPTY {
    %aws_redshift_cluster {
        Properties.PubliclyAccessible == false <<RS-003: Databasae should not be publicly accessible>>
    }
}


#RDS-004
let aws_rds_dbinstance = Resources.*[ Type == "AWS::RDS::DBInstance" ]
rule RDS_004 WHEN %aws_rds_dbinstance NOT EMPTY {
    %aws_rds_dbinstance {
        Properties.PubliclyAccessible != true <<RDS-004: RDS instances must not be publicially accessible>>
    }
}


#RDS-005
#TBD

#RDS-006
let aws_rds_dbinstance = Resources.*[ Type == "AWS::RDS::DBInstance" ]
rule RDS_006 when %aws_rds_dbinstance !empty {
    %aws_rds_dbinstance.Properties {
        MultiAZ != false <<RDS-006: RDS MultiAZ must be enabled for RDS instances>>
    }
}


#RDS-007
rule RDS_007 when %aws_rds_dbinstance !empty {
    %aws_rds_dbinstance.Properties {
        AutoMinorVersionUpgrade != false <<RDS-007: RDS auto minor version upgrade must be enabled>>
    }
}

#RDS-011
rule RDS_011 when %aws_rds_dbinstance !empty {
    %aws_rds_dbinstance.Properties {
    	DeletionProtection exists
        <<RDS-011: RDS instances must have Deletion Protection enabled>>
    }
}


#RDS-012
#TBD

#RDS-013
rule RDS_013 when %aws_rds_dbinstance_resources !empty {
  %aws_rds_dbinstance_resources.Properties {
  	DBParameterGroupName NOT EMPTY   <<RDS-013: Create and attach separate custom Options and Parameter Groups for every RDS deployment. Default groups must not be used. If you do not specify a value for the DBParameterGroupName property, the default DB parameter group for the specified engine and engine version is used.>>
  }
}

#RDS-014
let aws_rds_dbinstance_resources = Resources.*[ Type == 'AWS::RDS::DBInstance' ]
rule RDS_014 when %aws_rds_dbinstance_resources !empty {
  %aws_rds_dbinstance_resources.Properties {
  	EnableCloudwatchLogsExports[*] IN ["error","general","audit", "slowquery", "listerner", "trace"]
  <<RDS-014: DB logs (access, error, trace, slow query, long running query) must be enabled for all database engines.>> 
  }
}

#RDS-017
#TBD

#RS-008
#TBD

#RS-005
let aws_redshift_cluster_resources = Resources.*[ Type == 'AWS::Redshift::Cluster' ]
rule RS_005 when %aws_redshift_cluster_resources !empty {
  %aws_redshift_cluster_resources.Properties {
  	LoggingProperties EXISTS <<RS-005: Audit logging in Redshift cluster must be enabled>>
  }
}

#EKS-001
let awsqs_eks_cluster_resources = Resources.*[ Type == 'AWSQS::EKS::Cluster' ]
rule EKS_001 when %awsqs_eks_cluster_resources !empty {
  %awsqs_eks_cluster_resources.Properties {
  	EnabledClusterLoggingTypes == ["LoggingEnabled","EKSClusterLoggingTypes","AWS::NoValue"] <<<<EKS-001: cfn-guard rule can be modified based on cloudformation template. Control Plane Logging must be enabled in EKS cluster including Kubernetes API audit logs>>
  }
}

#SF-001
let aws_stepfunctions_statemachine_resources = Resources.*[ Type == 'AWS::StepFunctions::StateMachine' ]
rule SF_001 when %aws_stepfunctions_statemachine_resources !empty {
  %aws_stepfunctions_statemachine_resources.Properties {
  	LoggingConfiguration EXISTS <<SF-001: All Step Functions must be configured to export logs to a United-approved logging solution.>>
  }
}

#RS-006
let aws_redshift_clusterparametergroup_resources = Resources.*[ Type == 'AWS::Redshift::ClusterParameterGroup' ]
rule RS_006 when %aws_redshift_clusterparametergroup_resources !empty {
  %aws_redshift_clusterparametergroup_resources.Properties {
  	Parameters[*].ParameterName == 'require_ssl'
  	Parameters[*].ParameterValue == 'true'
  }
}

#DY-004
let aws_docdb_dbcluster_resources = Resources.*[ Type == 'AWS::DocDB::DBCluster' ]
rule DY_004 when %aws_docdb_dbcluster_resources !empty {
  %aws_docdb_dbcluster_resources.Properties {
  	KmsKeyId EXISTS <<DDB-001: Data stored in Document DB must be encrypted>>
  }
}

#EFS-003
let aws_iam_role_resources = Resources.*[ Type == 'AWS::IAM::Role' ]
rule EFS_003 when %aws_iam_role_resources !empty {
  %aws_iam_role_resources.Properties {
  	Policies.PolicyDocument.Statement[*].Effect == 'Allow'
  	Policies.PolicyDocument.Statement[*].Condition.Bool.'aws:SecureTransport' == 'true'
  }
}
